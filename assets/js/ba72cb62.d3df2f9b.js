(self.webpackChunknuke_website=self.webpackChunknuke_website||[]).push([[4663],{9405:function(e,n,t){"use strict";t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return c},default:function(){return k},frontMatter:function(){return d},metadata:function(){return m},toc:function(){return h}});var a=t(87462),i=t(63366),r=(t(67294),t(3905)),o=t(93456),s=t(9877),l=t(72360),p=["components"],d={title:"Build Components"},c=void 0,m={unversionedId:"sharing/build-components",id:"sharing/build-components",title:"Build Components",description:"With build components you can implement your build infrastructure once, and compose individual builds across different repositories. Central to the idea of build components are interface default implementations, which allow you separating targets by their concerns following the single-responsibility principle, and pulling them into your build just by inheriting the interface. A typical build based on components could look like this:",source:"@site/docs/04-sharing/02-build-components.md",sourceDirName:"04-sharing",slug:"/sharing/build-components",permalink:"/docs/sharing/build-components",draft:!1,editUrl:"https://github.com/nuke-build/nuke/edit/develop/website/docs/04-sharing/02-build-components.md",tags:[],version:"current",lastUpdatedBy:"Matthias Koch",lastUpdatedAt:1656273622,formattedLastUpdatedAt:"6/26/2022",sidebarPosition:2,frontMatter:{title:"Build Components"},sidebar:"tutorialSidebar",previous:{title:"Global Builds",permalink:"/docs/sharing/global-builds"},next:{title:"AppVeyor",permalink:"/docs/cicd/appveyor"}},u={},h=[{value:"Parameters",id:"parameters",level:2},{value:"Parameter Prefixes",id:"parameter-prefixes",level:3},{value:"Dependencies",id:"dependencies",level:2},{value:"Loose Dependencies",id:"loose-dependencies",level:3},{value:"Extensions and Overrides",id:"extensions-and-overrides",level:2}],g={toc:h};function k(e){var n=e.components,t=(0,i.Z)(e,p);return(0,r.kt)("wrapper",(0,a.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"With build components you can implement your build infrastructure once, and compose individual builds across different repositories. Central to the idea of build components are ",(0,r.kt)("a",{parentName:"p",href:"https://devblogs.microsoft.com/dotnet/default-implementations-in-interfaces/"},"interface default implementations"),", which allow you separating targets by their concerns following the ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Single-responsibility_principle"},"single-responsibility principle"),", and pulling them into your build just by inheriting the interface. A typical build based on components could look like this:"),(0,r.kt)(o.Mermaid,{chart:"classDiagram\n    direction BT\n\n    INukeBuild <|.. IPack\n    INukeBuild <|.. ICompile\n    INukeBuild <|.. ITest\n    IPack <|.. Build\n    ICompile <|.. Build\n    ITest <|.. Build\n\n    <<interface>> INukeBuild\n\n    <<interface>> IPack\n    IPack : + Target Pack\n\n    <<interface>> ICompile\n    ICompile : + Target Compile\n\n    <<interface>> ITest\n    ITest : + Target Test",mdxType:"Mermaid"}),(0,r.kt)("p",null,"The component stubs from above can be translated into code as follows, whereas the ",(0,r.kt)("inlineCode",{parentName:"p"},"INukeBuild")," base interface allows the components to use ",(0,r.kt)("a",{parentName:"p",href:"/docs/fundamentals/builds#base-properties"},"build base properties"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"interface ICompile : INukeBuild\n{\n    Target Compile => _ => _\n        .Executes(() => { /* Implementation */ });\n}\n\ninterface IPack : INukeBuild\n{\n    Target Pack => _ => _\n        .Executes(() => { /* Implementation */ });\n}\n\ninterface ITest : INukeBuild\n{\n    Target Test => _ => _\n        .Executes(() => { /* Implementation */ });\n}\n")),(0,r.kt)("p",null,"In the actual ",(0,r.kt)("inlineCode",{parentName:"p"},"Build")," class, all you have to do is to inherit the components:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"class Build : NukeBuild, ICompile, IPack, ITest\n{\n    // Targets are inherited\n}\n")),(0,r.kt)("h2",{id:"parameters"},"Parameters"),(0,r.kt)("p",null,"In build components, you can use ",(0,r.kt)("a",{parentName:"p",href:"/docs/fundamentals/parameters"},"parameters")," and other auto-injection attributes, like ",(0,r.kt)("a",{parentName:"p",href:"/docs/common/repository"},(0,r.kt)("inlineCode",{parentName:"a"},"GitRepositoryAttribute"))," or ",(0,r.kt)("a",{parentName:"p",href:"/docs/common/solution-project-model"},(0,r.kt)("inlineCode",{parentName:"a"},"SolutionAttribute")),", similar as in regular build classes. Though, since interfaces can't define instance fields or properties, the ",(0,r.kt)("inlineCode",{parentName:"p"},"INukeBuild")," base interface provides a helper method that caches and returns resolved values for you:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"interface IComponent : INukeBuild\n{\n    [Parameter]\n    string Parameter => TryGetValue(() => Parameter);\n\n    [Solution]\n    string Solution => TryGetValue(() => Solution);\n}\n")),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"TryGetValue")," method can return ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", for instance, when a parameter is not available. If you want to provide a default value, you can use the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator"},"null-coalescing operator"),":"),(0,r.kt)("pre",{parentName:"div"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'interface IComponent : INukeBuild\n{\n    [Parameter]\n    string Parameter => TryGetValue(() => Parameter) ?? "default";\n}\n')),(0,r.kt)("p",{parentName:"div"},"Note that the fallback value is created on every property access, so you might want to cache it in a static field. "))),(0,r.kt)("h3",{id:"parameter-prefixes"},"Parameter Prefixes"),(0,r.kt)("p",null,"For better distinction of similarly named component parameters and to avoid ",(0,r.kt)("a",{parentName:"p",href:"https://blog.codinghorror.com/new-programming-jargon/#21"},"smurf naming")," techniques, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ParameterPrefixAttribute")," to introduce a common prefix for all parameters in a component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[ParameterPrefix(nameof(IComponent1))]\ninterface IComponent1 : INukeBuild\n{\n    // Resolved as IComponent1Value\n    [Parameter] string Value => TryGetValue(() => Value);\n}\n\n[ParameterPrefix(nameof(IComponent2))]\ninterface IComponent2 : INukeBuild\n{\n    // Resolved as IComponent2Value\n    [Parameter] string Value => TryGetValue(() => Value);\n}\n")),(0,r.kt)("h2",{id:"dependencies"},"Dependencies"),(0,r.kt)("p",null,"You can define ",(0,r.kt)("a",{parentName:"p",href:"/docs/fundamentals/targets#dependencies"},"dependencies")," between targets similar as in regular build classes. Since targets from components cannot easily be referenced from their inheritors",(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),", you must pass the component type as a generic parameter and provide the target through a lambda expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"class Build : NukeBuild, IComponent\n{\n    Target MyTarget => _ => _\n        .DependsOn<IComponent>(x => x.Target)\n        .Executes(() =>\n        {\n        });\n}\n")),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"When a build component only defines a single target, you can use the shorthand syntax and omit the lambda that specifies the target. For instance, the above example can become:"),(0,r.kt)("pre",{parentName:"div"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"class Build : NukeBuild, IComponent\n{\n    Target MyTarget => _ => _\n        .DependsOn<IComponent>()\n        .Executes(() =>\n        {\n        });\n}\n")))),(0,r.kt)("h3",{id:"loose-dependencies"},"Loose Dependencies"),(0,r.kt)("p",null,"Apart from ",(0,r.kt)("a",{parentName:"p",href:"/docs/fundamentals/targets#dependencies"},"regular dependencies"),", you can also define loose dependencies that only get applied when the respective component is also inherited. This allows you to compose your build more flexibly without imposing a particular inheritance chain:"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"execution",label:"Execution Dependencies",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Build.cs"',title:'"Build.cs"'},"interface IComponent1 : INukeBuild\n{\n    Target A => _ => _\n        // highlight-start\n        .TryDependentFor<IComponent2>()      // Choose this...\n        // highlight-end\n        .Executes(() => { });\n}\n\ninterface IComponent2 : INukeBuild\n{\n    Target B => _ => _\n        // highlight-start\n        .TryDependsOn<IComponent1>()         // ...or this!\n        // highlight-end\n        .Executes(() => { });\n}\n"))),(0,r.kt)(l.Z,{value:"ordering",label:"Ordering Dependencies",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Build.cs"',title:'"Build.cs"'},"interface IComponent1 : INukeBuild\n{\n    Target A => _ => _\n        // highlight-start\n        .TryBefore<IComponent2>()            // Choose this...\n        // highlight-end\n        .Executes(() => { });\n}\n\ninterface IComponent2 : INukeBuild\n{\n    Target B => _ => _\n        // highlight-start\n        .TryAfter<IComponent1>()             // ...or this!\n        // highlight-end\n        .Executes(() => { });\n}\n"))),(0,r.kt)(l.Z,{value:"triggers",label:"Trigger Dependencies",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Build.cs"',title:'"Build.cs"'},"interface IComponent1 : INukeBuild\n{\n    Target A => _ => _\n        // highlight-start\n        .TryTriggers<IComponent2>()          // Choose this...\n        // highlight-end\n        .Executes(() => { });\n}\n\ninterface IComponent2 : INukeBuild\n{\n    Target B => _ => _\n        // highlight-start\n        .TryTriggeredBy<IComponent1>()       // ...or this!\n        // highlight-end\n        .Executes(() => { });\n}\n")))),(0,r.kt)("h2",{id:"extensions-and-overrides"},"Extensions and Overrides"),(0,r.kt)("p",null,"Another SOLID design principle that can be applied to build components is the ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle"},"open-closed principle"),". Once you have pulled a target into your build, it can be extended or overridden using ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation"},"explicit interface implementations"),":"),(0,r.kt)(s.Z,{groupId:"extensions-overrides",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"extensions",label:"Extending Targets",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"class Build : NukeBuild, IComponent\n{\n    Target IComponent.Target => _ => _\n        .Inherit<IComponent>()\n        .Executes(() => { });\n}\n"))),(0,r.kt)(l.Z,{value:"overrides",label:"Overriding Targets",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"class Build : NukeBuild, IComponent\n{\n    Target IComponent.Target => _ => _\n        .Executes(() => { });\n}\n")))),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"With build components you can push the separation of concerns as far as you wish. For instance, consider the following example where a common ",(0,r.kt)("inlineCode",{parentName:"p"},"ICompile")," component only defines the dependency to the ",(0,r.kt)("inlineCode",{parentName:"p"},"IRestore")," component. Another two derived types of ",(0,r.kt)("inlineCode",{parentName:"p"},"ICompile")," provide the actual implementation of the target using the .NET CLI and MSBuild:"),(0,r.kt)(o.Mermaid,{chart:"classDiagram\n    direction RL\n\n    ICompile --|> IRestore : TryDependsOn\n    ICompileWithDotNet <|.. ICompile\n    ICompileWithMSBuild <|.. ICompile\n\n    <<interface>> IRestore\n    IRestore : + Target Restore\n\n    <<interface>> ICompile\n    ICompile : + Target Compile\n\n    <<interface>> ICompileWithDotNet\n    ICompileWithDotNet : + Target Compile\n\n    <<interface>> ICompileWithMSBuild\n    ICompileWithMSBuild : + Target Compile",mdxType:"Mermaid"}),(0,r.kt)("pre",{parentName:"div"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"interface IRestore : INukeBuild\n{\n    Target Restore => _ => _\n        .Executes(() => { /* Implementation */ });\n}\n\ninterface ICompile : INukeBuild\n{\n    Target Compile => _ => _\n        .TryDependsOn<IRestore>();\n}\n\ninterface ICompileWithDotNet : ICompile\n{\n    Target ICompile.Compile => _ => _\n        .Inherit<ICompile>()\n        .Executes(() => { /* .NET CLI implementation */ });\n}\n\ninterface ICompileWithMSBuild : ICompile\n{\n    Target ICompile.Compile => _ => _\n        .Inherit<ICompile>()\n        .Executes(() => { /* MSBuild implementation */ });\n}\n")),(0,r.kt)("p",{parentName:"div"},"Targets that follow later in the execution plan can now reference the implementation-agnostic definition:"),(0,r.kt)("pre",{parentName:"div"},(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"class Build : NukeBuild, ICompileWithDotNet\n{\n    Target Pack => _ => _\n        .DependsOn<ICompile>()\n        .Executes(() => { /* Implementation */ });\n}\n")))),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1"},"Interface default members behave like explicit interface implementations, which means that to access their members, the ",(0,r.kt)("inlineCode",{parentName:"li"},"this")," reference must be cast explicitly to the interface type. For instance, ",(0,r.kt)("inlineCode",{parentName:"li"},"((IComponent)this).Target"),".",(0,r.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")))))}k.isMDXComponent=!0},11748:function(e,n,t){var a={"./locale":89234,"./locale.js":89234};function i(e){var n=r(e);return t(n)}function r(e){if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return a[e]}i.keys=function(){return Object.keys(a)},i.resolve=r,e.exports=i,i.id=11748}}]);