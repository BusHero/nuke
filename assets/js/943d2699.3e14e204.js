"use strict";(self.webpackChunknuke_website=self.webpackChunknuke_website||[]).push([[5484],{3905:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return d}});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(r),d=o,m=h["".concat(l,".").concat(d)]||h[d]||u[d]||i;return r?n.createElement(m,a(a({ref:t},p),{},{components:r})):n.createElement(m,a({ref:t},p))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=r[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},91383:function(e,t,r){r.r(t),r.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var n=r(87462),o=r(63366),i=(r(67294),r(3905)),a=["components"],s={title:"Constructing Paths"},l=void 0,c={unversionedId:"common/paths",id:"common/paths",title:"Constructing Paths",description:"Referencing files and directories seems like a trivial task. Nevertheless, developers often run into problems where relative paths no longer match the current working directory, or find themselves fixing path separator issues that stem from historical design decisions. NUKE follows the approach to use absolute paths whenever possible, which ensures explicitness and allows copying tool invocations from the log and executing them from anywhere you are.",source:"@site/docs/03-common/03-paths.md",sourceDirName:"03-common",slug:"/common/paths",permalink:"/docs/common/paths",draft:!1,editUrl:"https://github.com/nuke-build/nuke/edit/develop/website/docs/03-common/03-paths.md",tags:[],version:"current",lastUpdatedBy:"Matthias Koch",lastUpdatedAt:1656276144,formattedLastUpdatedAt:"6/26/2022",sidebarPosition:3,frontMatter:{title:"Constructing Paths"},sidebar:"tutorialSidebar",previous:{title:"Assertions",permalink:"/docs/fundamentals/assertions"},next:{title:"Repository Insights",permalink:"/docs/common/repository"}},p={},u=[{value:"Common Methods",id:"common-methods",level:2},{value:"Relative Paths",id:"relative-paths",level:2},{value:"Globbing",id:"globbing",level:2}],h={toc:u};function d(e){var t=e.components,r=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,n.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Referencing files and directories seems like a trivial task. Nevertheless, developers often run into problems where relative paths no longer match the current working directory, or find themselves fixing path separator issues that stem from ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=5T3IJfBfBmI"},"historical design decisions"),". NUKE follows the approach to use absolute paths whenever possible, which ensures explicitness and allows copying ",(0,i.kt)("a",{parentName:"p",href:"/docs/common/cli-tools"},"tool invocations")," from the log and executing them from anywhere you are."),(0,i.kt)("p",null,"Central to the idea of absolute paths is the ",(0,i.kt)("inlineCode",{parentName:"p"},"AbsolutePath")," type and the ",(0,i.kt)("inlineCode",{parentName:"p"},"NukeBuild.RootDirectory")," property. From there on, you can easily construct paths through the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading"},"overloaded division operator"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'AbsolutePath SourceDirectory => RootDirectory / "src";\nAbsolutePath OutputDirectory => RootDirectory / "output";\nAbsolutePath IndexFile => RootDirectory / "docs" / "index.md";\n')),(0,i.kt)("h2",{id:"common-methods"},"Common Methods"),(0,i.kt)("p",null,"While ",(0,i.kt)("inlineCode",{parentName:"p"},"AbsolutePath")," is agnostic to whether it points to a file or directory, it provides several commonly used methods for interaction:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// Get names\nvar nameWithExtension = IndexFile.Name;\nvar nameWithoutExtension = IndexFile.NameWithoutExtension; \n\n// Get the parent directory\nvar parent1 = IndexFile.Parent;\nvar parent2 = IndexFile / ".."; // gets normalized\n\n// Check if one path contains another\nvar containsFile = SourceDirectory.Contains(IndexFile);\n\n// Check if a directory or file exists\nvar directoryExists = SourceDirectory.DirectoryExists();\nvar fileExists = IndexFile.FileExists();\nvar pathExists = (RootDirectory / "dirOrFile").Exists(); // checks for both\n')),(0,i.kt)("h2",{id:"relative-paths"},"Relative Paths"),(0,i.kt)("p",null,"Occasionally, you may actually want relative paths, for instance to include them in manifest files that get shipped with your artifacts. In this case, you can make use of ",(0,i.kt)("inlineCode",{parentName:"p"},"RelativePath"),", which uses the path separator dictated by the operating system, or one of types ",(0,i.kt)("inlineCode",{parentName:"p"},"WinRelativePath")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"UnixRelativePath"),", which enforce using backslash or slash respectively:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"// Get the relative path to the index file\nvar indexRelativeFile = RootDirectory.GetRelativePathTo(IndexFile);\n\n// Get relative path for Unix\nvar indexUnixRelativePath1 = RootDirectory.GetUnixRelativePathTo(IndexFile);\nvar indexUnixRelativePath2 = (UnixRelativePath)indexRelativeFile;\n")),(0,i.kt)("p",null,"All relative path types support using the division operator."),(0,i.kt)("h2",{id:"globbing"},"Globbing"),(0,i.kt)("p",null,"Through the integrated ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/kthompson/glob"},"Glob")," NuGet package, you can use ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Glob_(programming)"},"globbing patterns")," to collect files or directories from a base directory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// Collect all package files from the output directory\nvar packageFiles = OutputDirectory.GlobFiles("*.nupkg");\n\n// Collect and delete all /obj and /bin directories in all sub-directories\nvar deletableDirectories = SourceDirectory.GlobDirectories("**/obj", "**/bin");\ndeletableDirectories.ForEach(FileSystemTasks.DeleteDirectory);\n')))}d.isMDXComponent=!0}}]);