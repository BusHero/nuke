"use strict";(self.webpackChunknuke_website=self.webpackChunknuke_website||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Introduction","href":"/docs/introduction","docId":"introduction"},{"type":"category","label":"Getting Started","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Installation","href":"/docs/getting-started/installation","docId":"getting-started/installation"},{"type":"link","label":"Build Setup","href":"/docs/getting-started/setup","docId":"getting-started/setup"},{"type":"link","label":"Build Execution","href":"/docs/getting-started/execution","docId":"getting-started/execution"},{"type":"link","label":"Telemetry","href":"/docs/getting-started/telemetry","docId":"getting-started/telemetry"}]},{"type":"category","label":"Fundamentals","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Build Anatomy","href":"/docs/fundamentals/builds","docId":"fundamentals/builds"},{"type":"link","label":"Target Definitions","href":"/docs/fundamentals/targets","docId":"fundamentals/targets"},{"type":"link","label":"Parameters","href":"/docs/fundamentals/parameters","docId":"fundamentals/parameters"},{"type":"link","label":"Logging","href":"/docs/fundamentals/logging","docId":"fundamentals/logging"},{"type":"link","label":"Assertions","href":"/docs/fundamentals/assertions","docId":"fundamentals/assertions"}]},{"type":"category","label":"Common Tasks","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Constructing Paths","href":"/docs/common/paths","docId":"common/paths"},{"type":"link","label":"Repository Insights","href":"/docs/common/repository","docId":"common/repository"},{"type":"link","label":"Data Serialization","href":"/docs/common/serialization","docId":"common/serialization"},{"type":"link","label":"Versioning Artifacts","href":"/docs/common/versioning","docId":"common/versioning"},{"type":"link","label":"Solution & Project Model","href":"/docs/common/solution-project-model","docId":"common/solution-project-model"},{"type":"link","label":"Invoking CLI Tools","href":"/docs/common/cli-tools","docId":"common/cli-tools"},{"type":"link","label":"Archive Compression","href":"/docs/common/compression","docId":"common/compression"},{"type":"link","label":"Chats & Social Media","href":"/docs/common/chats","docId":"common/chats"}]},{"type":"category","label":"Build Sharing","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Global Builds","href":"/docs/sharing/global-builds","docId":"sharing/global-builds"},{"type":"link","label":"Build Components","href":"/docs/sharing/build-components","docId":"sharing/build-components"}]},{"type":"category","label":"CI/CD Support","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"AppVeyor","href":"/docs/cicd/appveyor","docId":"cicd/appveyor"},{"type":"link","label":"Azure Pipelines","href":"/docs/cicd/azure-pipelines","docId":"cicd/azure-pipelines"},{"type":"link","label":"Bitbucket","href":"/docs/cicd/bitbucket","docId":"cicd/bitbucket"},{"type":"link","label":"GitHub Actions","href":"/docs/cicd/github-actions","docId":"cicd/github-actions"},{"type":"link","label":"GitLab","href":"/docs/cicd/gitlab","docId":"cicd/gitlab"},{"type":"link","label":"Jenkins","href":"/docs/cicd/jenkins","docId":"cicd/jenkins"},{"type":"link","label":"Space Automation","href":"/docs/cicd/space-automation","docId":"cicd/space-automation"},{"type":"link","label":"TeamCity","href":"/docs/cicd/teamcity","docId":"cicd/teamcity"}]},{"type":"category","label":"Global Tool","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Shell Completion","href":"/docs/global-tool/shell-completion","docId":"global-tool/shell-completion"},{"type":"link","label":"Adding NuGet Packages","href":"/docs/global-tool/packages","docId":"global-tool/packages"},{"type":"link","label":"Managing Secrets","href":"/docs/global-tool/secrets","docId":"global-tool/secrets"},{"type":"link","label":"Navigation","href":"/docs/global-tool/navigation","docId":"global-tool/navigation"},{"type":"link","label":"Converting from Cake","href":"/docs/global-tool/cake","docId":"global-tool/cake"}]},{"type":"category","label":"IDE Support","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"JetBrains Rider","href":"/docs/ide/rider","docId":"ide/rider"},{"type":"link","label":"ReSharper","href":"/docs/ide/resharper","docId":"ide/resharper"},{"type":"link","label":"Visual Studio","href":"/docs/ide/visual-studio","docId":"ide/visual-studio"},{"type":"link","label":"Visual Studio Code","href":"/docs/ide/vscode","docId":"ide/vscode"}]}]},"docs":{"cicd/appveyor":{"id":"cicd/appveyor","title":"AppVeyor","description":"Running on AppVeyor will automatically enable custom theming for your build log output:","sidebar":"tutorialSidebar"},"cicd/azure-pipelines":{"id":"cicd/azure-pipelines","title":"Azure Pipelines","description":"Running on Azure Pipelines will automatically enable custom theming for your build log output including collapsible sections for better structuring:","sidebar":"tutorialSidebar"},"cicd/bitbucket":{"id":"cicd/bitbucket","title":"Bitbucket","description":"Running on Bitbucket will use the standard theming for your build log output.","sidebar":"tutorialSidebar"},"cicd/github-actions":{"id":"cicd/github-actions","title":"GitHub Actions","description":"Running on GitHub Actions will automatically enable custom theming for your build log output including collapsible groups for better structuring:","sidebar":"tutorialSidebar"},"cicd/gitlab":{"id":"cicd/gitlab","title":"GitLab","description":"Running on GitLab will automatically enable custom theming for your build log output including collapsible sections for better structuring:","sidebar":"tutorialSidebar"},"cicd/jenkins":{"id":"cicd/jenkins","title":"Jenkins","description":"Running on Jenkins will use the standard theming for your build log output.","sidebar":"tutorialSidebar"},"cicd/space-automation":{"id":"cicd/space-automation","title":"Space Automation","description":"Running on JetBrains Space will use the standard theming for your build log output:","sidebar":"tutorialSidebar"},"cicd/teamcity":{"id":"cicd/teamcity","title":"TeamCity","description":"Running on TeamCity will automatically enable custom theming for your build log output including collapsible blocks for better structuring:","sidebar":"tutorialSidebar"},"common/chats":{"id":"common/chats","title":"Chats & Social Media","description":"As a final step of your build automation process, you may want to report errors or announce a new version through different chats and social media channels. NUKE comes with basic support for the most common platforms.","sidebar":"tutorialSidebar"},"common/cli-tools":{"id":"common/cli-tools","title":"Invoking CLI Tools","description":"Interacting with third-party command-line interface tools (CLIs) is an essential task in build automation. This includes a wide range of aspects, such as resolution of the tool path, construction of arguments to be passed, evaluation of the exit code and capturing of standard and error output. NUKE hides these concerns in dedicated auto-generated CLI task classes.","sidebar":"tutorialSidebar"},"common/compression":{"id":"common/compression","title":"Archive Compression","description":"In many situations you have to deal with compressed archives. Good examples are when you want to provide additional assets for your GitHub releases, or when you depend on other project\'s release assets yourself, and need to extract them before they can be used.","sidebar":"tutorialSidebar"},"common/paths":{"id":"common/paths","title":"Constructing Paths","description":"Referencing files and directories seems like a trivial task. Nevertheless, developers often run into problems where relative paths no longer match the current working directory, or find themselves fixing path separator issues that stem from historical design decisions. NUKE follows the approach to use absolute paths whenever possible, which ensures explicitness and allows copying tool invocations from the log and executing them from anywhere you are.","sidebar":"tutorialSidebar"},"common/repository":{"id":"common/repository","title":"Repository Insights","description":"Having knowledge about the current branch, applied tags, and the repository origin is eminently important in various scenarios. For instance, the deployment destination for an application is different whether executed from a release or personal branch. An announcement target may only be executed when running on the main branch. And in many cases it is advisable to include repository metadata, like origin and commit hash, into the artifacts for better traceability.","sidebar":"tutorialSidebar"},"common/serialization":{"id":"common/serialization","title":"Data Serialization","description":"Structured data plays an essential role in build automation. You may want to read a list of repositories to be checked out, write data that\'s consumed by another tool, or update version numbers of SDKs and tools you consume. The central entry point for data serialization is the SerializationTasks class, which comes with support for JSON, XML, and YAML.","sidebar":"tutorialSidebar"},"common/solution-project-model":{"id":"common/solution-project-model","title":"Solution & Project Model","description":"Particularly when building .NET applications, your build may require information related to solution or project files. Such information is often duplicated with string literals and quickly becomes out-of-date. For instance, when publishing a project you want to build for every target framework that is defined in the project file. NUKE has best-in-class support to read and modify the .NET solution and project model.","sidebar":"tutorialSidebar"},"common/versioning":{"id":"common/versioning","title":"Versioning Artifacts","description":"Whenever a build produces artifacts, those should be identifiable with a unique version number. This avoids making wrong expectations about available features or fixed bugs, and allows for clear discussions between developers, QA team, and product users. The most common version approaches are are semantic versioning and calendar versioning.","sidebar":"tutorialSidebar"},"fundamentals/assertions":{"id":"fundamentals/assertions","title":"Assertions","description":"As in any other codebase, it is good practice to assert assumptions before continuing with more heavy procedures in your build automation. When an assertion is violated, it usually entails that the build should fail immediately.","sidebar":"tutorialSidebar"},"fundamentals/builds":{"id":"fundamentals/builds","title":"Build Anatomy","description":"A build project is a regular .NET console application. However, unlike regular console applications, NUKE chooses to name the main class Build instead of Program. This establishes a convention and allows easier navigation in your solution. The Build class must inherit from the NukeBuild base class and define a Main method to invoke the build execution and define any number of default targets:","sidebar":"tutorialSidebar"},"fundamentals/logging":{"id":"fundamentals/logging","title":"Logging","description":"As with any other application, good logging greatly reduces the time to detect the source of errors and fix them quickly. NUKE integrates with Serilog and prepares a console and file logger for you. Most functions with side effects will automatically log their performed actions. This also includes invocations of CLI tools. Of course, you can also add your own log messages:","sidebar":"tutorialSidebar"},"fundamentals/parameters":{"id":"fundamentals/parameters","title":"Parameters","description":"Another important aspect of build automation is the ability of passing input values to your build. These input values can be anything from generic texts, numeric and enum values, file and directory paths, arrays of aforementioned, boolean flags, or secrets. NUKE comes with a succinct way to declare parameters and lets you set their values in various ways.","sidebar":"tutorialSidebar"},"fundamentals/targets":{"id":"fundamentals/targets","title":"Target Definitions","description":"Inside a Build class, you can define your build steps as Target properties. The implementation for a build step is provided as a lambda function through the Executes method:","sidebar":"tutorialSidebar"},"getting-started/execution":{"id":"getting-started/execution","title":"Build Execution","description":"After you\'ve set up a build you can run it either through the global tool or one of the installed bootstrapping scripts:","sidebar":"tutorialSidebar"},"getting-started/installation":{"id":"getting-started/installation","title":"Installation","description":"Before you can set up a build project, you need to install NUKE\'s dedicated .NET global tool:","sidebar":"tutorialSidebar"},"getting-started/setup":{"id":"getting-started/setup","title":"Build Setup","description":"After installing the NUKE global tool, you can call it from anywhere on your machine to set up a new build:","sidebar":"tutorialSidebar"},"getting-started/telemetry":{"id":"getting-started/telemetry","title":"Telemetry","description":"As an effort to improve NUKE and to provide you with a better, more tailored experience, we include a telemetry feature that collects anonymous usage data and enables us to make more informed decisions for the future.","sidebar":"tutorialSidebar"},"global-tool/cake":{"id":"global-tool/cake","title":"Converting from Cake","description":"Over the years, the .NET community has come up with a lot of great build automation tools, including FAKE, Cake, FlubuCore, and BullsEye. When coming from Cake Scripting, the time for converting build scripts can be greatly reduced with a best-effort approach using Roslyn and its syntax transformation capabilities.","sidebar":"tutorialSidebar"},"global-tool/navigation":{"id":"global-tool/navigation","title":"Navigation","description":"Over time you might accumulate more and more projects that are built using NUKE. Some of these might even form a hierarchical structure, where one root directory contains several other root directories, and so on.","sidebar":"tutorialSidebar"},"global-tool/packages":{"id":"global-tool/packages","title":"Adding NuGet Packages","description":"In many cases, build automation relies on third-party tools. NUKE provides you with a great API for working with CLI tools, however, it is the responsibility of a build project to reference these tools in the form of NuGet packages and define their exact versions.","sidebar":"tutorialSidebar"},"global-tool/secrets":{"id":"global-tool/secrets","title":"Managing Secrets","description":"Historically, secret values like passwords or auth-tokens are often saved as environment variables on local machines or CI/CD servers. This imposes both, security issues because other processes can access these environment variables and inconveniences when a build must be executed locally for emergency reasons (server downtime). NUKE has an integrated encryption utility, which can be used to save and load secret values to and from parameter files.","sidebar":"tutorialSidebar"},"global-tool/shell-completion":{"id":"global-tool/shell-completion","title":"Shell Completion","description":"Typing long target names or parameters can be tedious and error-prone. The NUKE global tool can help you enter invocations more quickly and without typos.","sidebar":"tutorialSidebar"},"ide/resharper":{"id":"ide/resharper","title":"ReSharper","description":"<InstallButton","sidebar":"tutorialSidebar"},"ide/rider":{"id":"ide/rider","title":"JetBrains Rider","description":"<RiderInstallButton","sidebar":"tutorialSidebar"},"ide/visual-studio":{"id":"ide/visual-studio","title":"Visual Studio","description":"<InstallButton","sidebar":"tutorialSidebar"},"ide/vscode":{"id":"ide/vscode","title":"Visual Studio Code","description":"<InstallButton","sidebar":"tutorialSidebar"},"introduction":{"id":"introduction","title":"Introduction","description":"\ud83e\udeb4 Write automation tools and CI/CD pipelines in plain C# and with access to all .NET libraries.","sidebar":"tutorialSidebar"},"sharing/build-components":{"id":"sharing/build-components","title":"Build Components","description":"With build components you can implement your build infrastructure once, and compose individual builds across different repositories. Central to the idea of build components are interface default implementations, which allow you separating targets by their concerns following the single-responsibility principle, and pulling them into your build just by inheriting the interface. A typical build based on components could look like this:","sidebar":"tutorialSidebar"},"sharing/global-builds":{"id":"sharing/global-builds","title":"Global Builds","description":"Instead of adding and maintaining build projects in all your repositories, you can also build them by convention using a global build. Global builds are based on the concept of .NET global tools and additionally include all the necessary tools referenced through NuGet packages. That means that for building one of your repositories, you only need to install and execute your pre-packaged build.","sidebar":"tutorialSidebar"}}}')}}]);